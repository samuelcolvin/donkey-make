use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

use ansi_term::Colour::Fixed;
use linked_hash_map::LinkedHashMap as Map;

use crate::commands::{Cmd, FileConfig, Watch};
use crate::execute::Run;
use crate::utils::{
    full_path, CliArgs, BAR, DONKEY_COMMAND_ENV, DONKEY_DEPTH_ENV, DONKEY_FILE_ENV, DONKEY_KEEP_ENV, PATH_STR,
};

pub fn main(cmd_name: &str, config: &FileConfig, cmd: &Cmd, cli: &CliArgs, file_path: &PathBuf) -> Result<Run, String> {
    let mut path_str: String = PATH_STR.to_string();
    let mut run_depth: i32 = 0;
    if let Ok(v) = env::var(DONKEY_DEPTH_ENV) {
        path_str = format!("{}.{}", PATH_STR, v);
        run_depth = v.parse::<i32>().unwrap_or(1);
    }
    let smart_prefix = match env::var(DONKEY_COMMAND_ENV) {
        Ok(c) => format!("{} {} ›", c, cmd_name),
        _ => "»".to_string(),
    };
    let mut args: Vec<String> = vec![path_str.clone()];
    args.extend(cmd.args.iter().cloned());
    args.extend(cli.args.iter().cloned());

    let mut env: Map<String, String> = Map::new();
    merge_maps(&mut env, &config.env);
    merge_maps(&mut env, &cmd.env);
    env.insert(DONKEY_DEPTH_ENV.to_string(), (run_depth + 1).to_string());
    env.insert(DONKEY_FILE_ENV.to_string(), full_path(file_path));
    env.insert(DONKEY_COMMAND_ENV.to_string(), smart_prefix.clone());
    env.insert(
        DONKEY_KEEP_ENV.to_string(),
        String::from(if cli.keep_tmp { "1" } else { "0" }),
    );

    let working_dir = get_working_dir(&cmd, file_path)?;

    let watch_path: Option<PathBuf> = match &cmd.watch {
        Some(Watch { path, .. }) => {
            let mut p = PathBuf::from(path);
            if p.is_relative() {
                p = working_dir.join(&p).to_path_buf();
            }
            if !p.exists() {
                return err!("The watch directory \"{}\" does not exist", full_path(&p));
            }
            Some(p)
        }
        _ => None,
    };

    let tmp_path = working_dir.join(&path_str);
    write(cmd_name, &tmp_path, cmd, &args, &env, config, smart_prefix)?;

    Ok(Run {
        cmd_name: cmd_name.to_string(),
        args,
        env,
        working_dir,
        tmp_path,
        file_path: file_path.to_path_buf(),
        watch_path,
        print_summary: run_depth == 0,
    })
}

fn write(
    cmd_name: &str,
    path: &PathBuf,
    cmd: &Cmd,
    args: &[String],
    env: &Map<String, String>,
    config: &FileConfig,
    smart_prefix: String,
) -> Result<(), String> {
    if path.exists() {
        return err!(
            "Error writing temporary file:\n  {} already exists, donkey-make may be running already",
            path.display()
        );
    }

    let prefix: Vec<String> = vec![
        String::from(BAR),
        format!(
            "This is a temporary file generated by donkey-make to execute the command: \"{}\"",
            cmd_name
        ),
        format!("Command to be executed: \"{} {}\"", cmd.executable(), args.join(" ")),
        String::from("Environment variables set:"),
        format!("{:?}", env),
        String::from("This file should only exist very temporarily while it's being executed."),
        String::from(BAR),
    ];
    let comment = if cmd.executable().starts_with("node") {
        "//"
    } else {
        "#"
    };
    let sep = format!("\n{} ", comment);

    let script: String = if cmd.smart() {
        let donk_exe = match env::current_exe() {
            Ok(ex) => full_path(&ex),
            Err(e) => return err!("finding current executable for smart script failed: {}", e),
        };
        let mut cmd_tree: HashSet<String> = HashSet::new();
        cmd_tree.insert((*cmd_name).to_string());
        build_smart_script(&cmd, smart_prefix, &donk_exe, config, &mut cmd_tree)?
    } else {
        cmd.run.join("\n")
    };

    let content = format!("{} {}\n{}", comment, prefix.join(&sep), script);

    match create_file(path, &content) {
        Ok(_) => Ok(()),
        Err(e) => err!("Error writing temporary file {}:\n  {}", path.display(), e),
    }
}

fn create_file(path: &Path, content: &str) -> std::io::Result<()> {
    let mut f = fs::File::create(path)?;
    f.write_all(content.as_bytes())?;
    Ok(())
}

const NO_ECHO_PREFIX: char = '_';
const DONK_PREFIX: char = '+';
const INLINE_PREFIX: char = '<';
const PREFIXES: [char; 3] = [NO_ECHO_PREFIX, DONK_PREFIX, INLINE_PREFIX];

fn build_smart_script(
    cmd: &Cmd,
    smart_prefix: String,
    donk_exe: &str,
    config: &FileConfig,
    cmd_tree: &mut HashSet<String>,
) -> Result<String, String> {
    let all = cmd.run.join("\n");
    let lines: Vec<&str> = all.split('\n').collect();
    let len = lines.len();

    let mut script: Vec<String> = vec!["set -e".to_string()];
    for line in lines {
        if !PREFIXES.iter().any(|&prefix| line.starts_with(prefix)) {
            let coloured = epaint!(Fixed(205), format!("{} {}", smart_prefix, line));
            script.push(format!(">&2 echo '{}'", coloured));
        }

        let mut ex_line = if line.starts_with(NO_ECHO_PREFIX) {
            line[1..].to_string()
        } else {
            line.to_string()
        };

        if ex_line.starts_with(INLINE_PREFIX) {
            let sub_cmd_name = &ex_line[1..].trim().to_string();
            if cmd_tree.contains(sub_cmd_name) {
                return err!(
                    "Command \"{}\" reused in an inline sub-command, this would cause infinite recursion",
                    sub_cmd_name
                );
            }
            cmd_tree.insert(sub_cmd_name.clone().to_string());
            let sub_cmd = get_sub_command(config, sub_cmd_name)?;
            let sub_cmd_prefix = format!("{} {} ›", smart_prefix, sub_cmd_name);
            ex_line = build_smart_script(sub_cmd, sub_cmd_prefix, donk_exe, config, &mut *cmd_tree)?;
        } else {
            if len == 1 && !line.contains('$') {
                // must be the first line
                ex_line = format!("{} $@", line)
            }
            if ex_line.starts_with(DONK_PREFIX) {
                ex_line = format!("{} {}", donk_exe, &ex_line[1..]);
            }
        }
        script.push(ex_line);
    }
    Ok(script.join("\n"))
}

fn get_sub_command<'a>(config: &'a FileConfig, cmd_name: &str) -> Result<&'a Cmd, String> {
    match config.commands.get(cmd_name) {
        Some(c) => {
            if c.smart() {
                Ok(c)
            } else {
                err!(
                    "Sub-command \"{}\" not a bash-smart script, remove \"ex:\" or use '{}' not '{}'",
                    cmd_name,
                    DONK_PREFIX,
                    INLINE_PREFIX
                )
            }
        }
        None => err!(
            "Sub-command \"{}\" not found, commands available are:\n  {}",
            cmd_name,
            config.keys().join(", ")
        ),
    }
}

fn merge_maps(base: &mut Map<String, String>, update: &Map<String, String>) {
    base.extend(update.iter().map(|(k, v)| (k.clone(), v.clone())));
}

fn get_working_dir(cmd: &Cmd, file_path: &PathBuf) -> Result<PathBuf, String> {
    match &cmd.working_dir {
        Some(wd) => {
            let mut path = PathBuf::from(&wd);
            if path.is_relative() {
                let file_dir = match file_path.parent() {
                    Some(p) => p,
                    _ => return err!("\"{}\" path appears to have no parent directory", file_path.display()),
                };
                path = file_dir.join(&wd).to_path_buf();
            }
            if !path.is_dir() {
                err!("\"{}\" is not a directory", &wd)
            } else {
                Ok(match path.canonicalize() {
                    Ok(p) => p,
                    _ => path,
                })
            }
        }
        _ => match env::current_dir() {
            Ok(p) => Ok(p),
            Err(e) => err!("unable to resolve current working directory: {}", e),
        },
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use linked_hash_map::LinkedHashMap as Map;

    #[test]
    fn merge_add() {
        let mut base: Map<String, String> = Map::new();
        base.insert("a".to_string(), "b".to_string());
        let mut update: Map<String, String> = Map::new();
        update.insert("c".to_string(), "d".to_string());
        merge_maps(&mut base, &update);
        assert_eq!(format!("{:?}", base), r#"{"a": "b", "c": "d"}"#);
    }

    #[test]
    fn merge_update() {
        let mut base: Map<String, String> = Map::new();
        base.insert("a".to_string(), "b".to_string());
        let mut update: Map<String, String> = Map::new();
        update.insert("a".to_string(), "d".to_string());
        merge_maps(&mut base, &update);
        assert_eq!(format!("{:?}", base), r#"{"a": "d"}"#);
    }
}
