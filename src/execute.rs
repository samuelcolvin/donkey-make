use std::env;
use std::fs;
use std::io::Error;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, SystemTime};

use ansi_term::Colour::{Green, Yellow};
use linked_hash_map::LinkedHashMap as Map;

use crate::commands::{Cmd, FileConfig};
use crate::consts::{CliArgs, BAR, DONKEY_DEPTH_ENV, DONKEY_FILE_ENV, PATH_STR};

pub fn main(
    command_name: &str,
    config: &FileConfig,
    cmd: &Cmd,
    cli: &CliArgs,
    file_path: &PathBuf,
) -> Result<Option<i32>, String> {
    let mut path_str: String = PATH_STR.to_string();
    let mut next_env: i32 = 1;
    if let Ok(v) = env::var(DONKEY_DEPTH_ENV) {
        path_str = format!("{}.{}", PATH_STR, v);
        next_env = v.parse::<i32>().unwrap_or(1) + 1;
    }

    let mut args: Vec<String> = vec![path_str.clone()];
    args.extend(cmd.args.iter().cloned());
    args.extend(cli.args.iter().cloned());

    let mut env: StrMap = Map::new();
    merge_maps(&mut env, &config.env);
    merge_maps(&mut env, &cmd.env);
    env.insert(DONKEY_DEPTH_ENV.to_string(), format!("{}", next_env));
    env.insert(DONKEY_FILE_ENV.to_string(), to_full_string(file_path));

    let path = Path::new(&path_str);
    write(command_name, path, cmd, &args, &env)?;
    let exit_code = run_command(command_name, cmd, &args, &env);
    delete(path, cli.delete_tmp)?;
    match exit_code {
        Ok(t) => Ok(t),
        Err(e) => err!(
            "failed to execute command \"{} {}\": {}",
            cmd.executable(),
            args.join(" "),
            e
        ),
    }
}

fn write(command_name: &str, path: &Path, cmd: &Cmd, args: &[String], env: &StrMap) -> Result<(), String> {
    if path.exists() {
        return err!(
            "Error writing temporary file:\n  {} already exists, donkey-make may be running already",
            path.display()
        );
    }

    let prefix: Vec<String> = vec![
        String::from(BAR),
        format!(
            "This is a temporary file generated by donkey-make to execute the command: \"{}\"",
            command_name
        ),
        format!("Command to be executed: \"{} {}\"", cmd.executable(), args.join(" ")),
        String::from("Environment variables set:"),
        format!("{:?}", env),
        String::from("This file should only exist very temporarily while it's be executed."),
        String::from(BAR),
    ];
    let comment = if cmd.executable().starts_with("node") {
        "//"
    } else {
        "#"
    };
    let sep = format!("\n{} ", comment);

    let script: String = if cmd.smart() {
        build_smart_script(&cmd.run)?
    } else {
        cmd.run.join("\n")
    };

    let content = format!("{} {}\n{}", comment, prefix.join(&sep), script);

    match create_file(path, &content) {
        Ok(_) => Ok(()),
        Err(e) => err!("Error writing temporary file {}:\n  {}", path.display(), e),
    }
}

fn run_command(command_name: &str, cmd: &Cmd, args: &[String], env: &StrMap) -> Result<Option<i32>, Error> {
    let mut c = Command::new(&cmd.executable());
    c.args(args).envs(env);
    let sig = register_signals()?;

    let tic = SystemTime::now();
    let status = c.status()?;
    let toc = SystemTime::now();
    let dur_str = format_duration(tic, toc);
    if status.success() {
        printlnc!(Green, "Command \"{}\" successful, took {}", command_name, dur_str);
        Ok(None)
    } else {
        match status.code() {
            Some(c) => {
                printlnc!(
                    Yellow,
                    "Command \"{}\" failed, took {}, exit code {}",
                    command_name,
                    dur_str,
                    c
                );
                Ok(Some(c))
            }
            None => {
                printlnc!(
                    Yellow,
                    "Command \"{}\" kill with signal {} after {}",
                    command_name,
                    signal_name(sig),
                    dur_str
                );
                Ok(Some(99))
            }
        }
    }
}

fn delete(path: &Path, delete: bool) -> Result<(), String> {
    if delete {
        match fs::remove_file(path) {
            Ok(t) => t,
            Err(e) => {
                return err!("Error deleting temporary file {}, {}", path.display(), e);
            }
        };
    }
    Ok(())
}

fn create_file(path: &Path, content: &str) -> std::io::Result<()> {
    let mut f = fs::File::create(path)?;
    f.write_all(content.as_bytes())?;
    Ok(())
}

struct Signal {
    int: Arc<AtomicBool>,
    term: Arc<AtomicBool>,
}

fn register_signals() -> Result<Signal, Error> {
    let sig = Signal {
        int: Arc::new(AtomicBool::new(false)),
        term: Arc::new(AtomicBool::new(false)),
    };
    // TODO this doesn't forward the signal to the child, but generally the terminal does that for us
    signal_hook::flag::register(signal_hook::SIGINT, Arc::clone(&sig.int))?;
    signal_hook::flag::register(signal_hook::SIGTERM, Arc::clone(&sig.term))?;
    Ok(sig)
}

fn signal_name(sig: Signal) -> &'static str {
    if sig.int.load(Ordering::Relaxed) {
        "SIGINT"
    } else if sig.term.load(Ordering::Relaxed) {
        "SIGTERM"
    } else {
        "UNKNOWN"
    }
}

const DONK_PREFIX: &str = "\nD";

fn build_smart_script(original: &[String]) -> Result<String, String> {
    // https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html
    let mut script_lines: Vec<String> = vec!["set -ex".to_string()];
    if original.len() == 1 {
        if let Some(line) = original.first() {
            if !line.contains('$') {
                script_lines.push(format!("{} $@", line));
            }
        }
    } else {
        script_lines.extend(original.iter().cloned());
    }
    let script = script_lines.join("\n");
    if script.contains(DONK_PREFIX) {
        match env::current_exe() {
            Ok(ex) => Ok(script.replace(DONK_PREFIX, &format!("\n{}", to_full_string(&ex)))),
            Err(e) => err!("substituting D in smart script failed: {}", e),
        }
    } else {
        Ok(script)
    }
}

type StrMap = Map<String, String>;

fn merge_maps(base: &mut StrMap, update: &StrMap) {
    base.extend(update.iter().map(|(k, v)| (k.clone(), v.clone())));
}

fn format_duration(tic: SystemTime, toc: SystemTime) -> String {
    match toc.duration_since(tic).unwrap_or(Duration::from_secs(0)) {
        d if d < Duration::from_millis(10) => format!("{:0.3}ms", d.subsec_micros() as f32 / 1000.0),
        d if d < Duration::from_secs(1) => format!("{}ms", d.subsec_millis()),
        d if d < Duration::from_secs(100) => {
            format!("{:0.3}s", d.as_secs() as f64 + f64::from(d.subsec_millis()) / 1000.0)
        }
        d => format!("{}s", d.as_secs()),
    }
}

fn to_full_string(path: &PathBuf) -> String {
    match path.canonicalize() {
        Ok(p) => p.to_string_lossy().to_string(),
        _ => path.to_string_lossy().to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use linked_hash_map::LinkedHashMap as Map;
    use std::time::{Duration, SystemTime};

    #[test]
    fn format_duration_5ms() {
        let tic = SystemTime::now();
        let toc = tic + Duration::from_millis(5);
        assert_eq!(format_duration(tic, toc), "5.000ms");
    }

    #[test]
    fn format_duration_15ms() {
        let tic = SystemTime::now();
        let toc = tic + Duration::from_millis(15);
        assert_eq!(format_duration(tic, toc), "15ms");
    }

    #[test]
    fn format_duration_2s() {
        let tic = SystemTime::now();
        let toc = tic + Duration::from_secs(2);
        assert_eq!(format_duration(tic, toc), "2.000s");
    }

    #[test]
    fn format_duration_200s() {
        let tic = SystemTime::now();
        let toc = tic + Duration::from_secs(200);
        assert_eq!(format_duration(tic, toc), "200s");
    }

    #[test]
    fn merge_add() {
        let mut base: Map<String, String> = Map::new();
        base.insert("a".to_string(), "b".to_string());
        let mut update: Map<String, String> = Map::new();
        update.insert("c".to_string(), "d".to_string());
        merge_maps(&mut base, &update);
        assert_eq!(format!("{:?}", base), r#"{"a": "b", "c": "d"}"#);
    }

    #[test]
    fn merge_update() {
        let mut base: Map<String, String> = Map::new();
        base.insert("a".to_string(), "b".to_string());
        let mut update: Map<String, String> = Map::new();
        update.insert("a".to_string(), "d".to_string());
        merge_maps(&mut base, &update);
        assert_eq!(format!("{:?}", base), r#"{"a": "d"}"#);
    }
}
