use std::collections::BTreeMap as Map;
use std::fs;
use std::io::Write;
use std::path::Path;
use std::process::Command;
use std::time::{Duration, SystemTime};

use ansi_term::Colour::{Green, Yellow};

use crate::commands::{Cmd, FileConfig};

const PATH_STR: &str = ".donkey-make.tmp";
const BAR: &str = "==========================================================================================";

pub fn main(command_name: &str, config: &FileConfig, cmd: &Cmd, cli_args: &[String], delete_tmp: bool) -> Option<i32> {
    let mut args: Vec<String> = vec![PATH_STR.to_string()];
    extend_vec(&mut args, &cmd.args);
    extend_vec(&mut args, &cli_args);

    let mut env: StrMap = Map::new();
    merge_maps(&mut env, &config.env);
    merge_maps(&mut env, &cmd.env);

    write(command_name, cmd, &args, &env);
    run_command(command_name, cmd, &args, &env, delete_tmp)
}

fn write(command_name: &str, cmd: &Cmd, args: &[String], env: &StrMap) {
    let path = Path::new(PATH_STR);
    if path.exists() {
        exit!(
            "Error writing temporary file:\n  {} already exists, donkey-make may be running already",
            PATH_STR
        );
    }

    let prefix: Vec<String> = vec![
        BAR.to_string(),
        format!(
            "This is a temporary file generated by donkey-make to execute the command: \"{}\"",
            command_name
        ),
        format!("Command to be executed: \"{} {}\"", cmd.executable, args.join(" ")),
        format!("Environment variables set: {:?}", env),
        "This file should only exist very temporarily while it's be executed.".to_string(),
        BAR.to_string(),
    ];
    let comment = if cmd.executable.starts_with("node") { "//" } else { "#" };
    let sep = format!("\n{} ", comment);
    let content = format!("{} {}\n{}", comment, prefix.join(&sep), cmd.run.join("\n"));

    match create_file(path, &content) {
        Ok(t) => t,
        Err(e) => {
            exit!("Error writing temporary file {}:\n  {}", PATH_STR, e);
        }
    };
}

fn run_command(command_name: &str, cmd: &Cmd, args: &[String], env: &StrMap, delete_tmp: bool) -> Option<i32> {
    let mut c = Command::new(&cmd.executable);
    c.args(args).envs(env);

    let tic = SystemTime::now();
    let status = match c.status() {
        Ok(t) => t,
        Err(e) => {
            delete(delete_tmp);
            exit!(
                "failed to execute command \"{} {}\": {}",
                cmd.executable,
                args.join(" "),
                e
            );
        }
    };
    let toc = SystemTime::now();
    delete(delete_tmp);
    let dur_str = format_duration(tic, toc);
    if status.success() {
        printlnc!(Green, "Command \"{}\" successful, took {}", command_name, dur_str);
        None
    } else {
        match status.code() {
            Some(c) => {
                printlnc!(
                    Yellow,
                    "Command \"{}\" failed, took {}, exit code {}",
                    command_name,
                    dur_str,
                    c
                );
                Some(c)
            }
            None => {
                printlnc!(
                    Yellow,
                    "Command \"{}\" failed, took {}, no exit code (probably terminated by a signal)",
                    command_name,
                    dur_str
                );
                Some(2)
            }
        }
    }
}

fn delete(delete: bool) {
    if delete {
        let path = Path::new(PATH_STR);
        match fs::remove_file(path) {
            Ok(t) => t,
            Err(e) => {
                exit!("Error deleting temporary file {}, {}", PATH_STR, e);
            }
        };
    }
}

fn create_file(path: &Path, content: &str) -> std::io::Result<()> {
    let mut f = fs::File::create(path)?;
    f.write_all(content.as_bytes())?;
    Ok(())
}

type StrMap = Map<String, String>;

fn merge_maps(base: &mut StrMap, update: &StrMap) {
    base.extend(update.iter().map(|(k, v)| (k.clone(), v.clone())));
}

fn extend_vec(base: &mut Vec<String>, extend: &[String]) {
    base.extend(extend.iter().cloned());
}

fn format_duration(tic: SystemTime, toc: SystemTime) -> String {
    match toc.duration_since(tic).unwrap() {
        d if d < Duration::from_millis(10) => format!("{:0.3}ms", d.subsec_micros() as f32 / 1000.0),
        d if d < Duration::from_secs(1) => format!("{}ms", d.subsec_millis()),
        d if d < Duration::from_secs(100) => {
            format!("{:0.3}s", d.as_secs() as f64 + f64::from(d.subsec_millis()) / 1000.0)
        }
        d => format!("{}s", d.as_secs()),
    }
}
