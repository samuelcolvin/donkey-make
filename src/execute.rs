use std::collections::BTreeMap as Map;
use std::fs;
use std::io::Write;
use std::path::Path;
use std::process::Command;
use std::time::{Duration, SystemTime};

use ansi_term::Colour::{Green, Yellow};

use crate::commands::{Cmd, FileConfig};

const PATH_STR: &str = ".donkey-make.tmp";
const BAR: &str = "==========================================================================================";

pub fn main(
    command_name: &str,
    config: &FileConfig,
    cmd: &Cmd,
    cli_args: &Vec<String>,
    delete_tmp: bool,
) -> Option<i32> {
    let mut args: StrVec = vec![PATH_STR.to_string()];
    extend_vec(&mut args, &cmd.args);
    extend_vec(&mut args, &cli_args);

    let mut env: StrMap = Map::new();
    merge_maps(&mut env, &config.env);
    merge_maps(&mut env, &cmd.env);

    write(command_name, cmd, &args, &env);
    run_command(command_name, cmd, &args, &env, delete_tmp)
}

fn write(command_name: &str, cmd: &Cmd, args: &StrVec, env: &StrMap) {
    let path = Path::new(PATH_STR);
    if path.exists() {
        exit!(
            "Error writing temporary file:\n  {} already exists, donkey-make must be running already",
            PATH_STR
        );
    }

    let prefix: StrVec = vec![
        BAR.to_string(),
        format!("This is a temporary file generated by donkey-make to execute the command: \"{}\"", command_name),
        format!("Command to be executed: \"{} {}\"", cmd.executable, args.join(" ")),
        format!("Environment variables set: {:?}", env),
        "This file should only exist very temporarily while it's be executed.".to_string(),
        BAR.to_string(),
    ];
    let comment = match cmd.executable.starts_with("node") {
        true => "//",
        _ => "#",
    };
    let sep = format!("\n{} ", comment);

    let content = format!("{} {}\n{}", comment, prefix.join(&sep), cmd.run.join("\n"));

    match create_file(path, &content) {
        Ok(t) => t,
        Err(e) => {
            exit!("Error writing temporary file {}:\n  {}", PATH_STR, e);
        }
    };
}

fn run_command(command_name: &str, cmd: &Cmd, args: &StrVec, env: &StrMap, delete_tmp: bool) -> Option<i32> {
    let mut c = Command::new(&cmd.executable);
    c.args(args).envs(env);

    let tic = SystemTime::now();
    let status = match c.status() {
        Ok(t) => t,
        Err(e) => {
            delete(delete_tmp);
            exit!(r#"failed to execute command "{} {}": {}"#, cmd.executable, args.join(" "), e);
        }
    };
    let toc = SystemTime::now();
    delete(delete_tmp);
    let dur_str = format_duration(tic, toc);
    if status.success() {
        printlnc!(Green, "Command \"{}\" successful, took {}", command_name, dur_str);
        return None;
    } else {
        match status.code() {
            Some(c) => {
                printlnc!(
                    Yellow,
                    "Command \"{}\" failed, took {}, exit code {}",
                    command_name,
                    dur_str,
                    c
                );
                return Some(c);
            }
            None => {
                printlnc!(
                    Yellow,
                    "Command \"{}\" failed, took {}, no exit code (probably terminated by a signal)",
                    command_name,
                    dur_str
                );
                return Some(2);
            }
        }
    };
}

fn delete(delete: bool) {
    if delete {
        let path = Path::new(PATH_STR);
        match fs::remove_file(path) {
            Ok(t) => t,
            Err(e) => {
                exit!("Error deleting temporary file {}, {}", PATH_STR, e);
            }
        };
    }
}

fn create_file(path: &Path, content: &str) -> std::io::Result<()> {
    let mut f = fs::File::create(path)?;
    f.write_all(content.as_bytes())?;
    Ok(())
}

type StrMap = Map<String, String>;
type StrVec = Vec<String>;

fn merge_maps(base: &mut StrMap, update: &StrMap) {
    base.extend(update.into_iter().map(|(k, v)| (k.clone(), v.clone())));
}

fn extend_vec(base: &mut StrVec, extend: &StrVec) {
    base.extend(extend.iter().map(|v| v.clone()));
}

fn format_duration(tic: SystemTime, toc: SystemTime) -> String {
    match toc.duration_since(tic).unwrap() {
        d if d < Duration::from_millis(10) => {
            let diff_ms = d.subsec_micros() as f32 / 1000.0;
            format!("{:0.3}ms", diff_ms)
        }
        d if d < Duration::from_secs(1) => format!("{:0.0}ms", d.subsec_millis()),
        d if d < Duration::from_secs(100) => {
            let diff_s = d.as_secs() as f64 + d.subsec_millis() as f64 / 1000.0;
            format!("{:0.2}s", diff_s)
        }
        d => format!("{}s", d.as_secs()),
    }
}
