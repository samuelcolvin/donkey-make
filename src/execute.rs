use std::fs;
use std::io::Write;
use std::os::unix::fs::PermissionsExt;
use std::path::Path;
use std::process;
use std::process::{Command};

static PATH_STR: &str = "~donkey-make.tmp";

use crate::commands::Cmd;

pub fn main(command_name: &str, cmd: &Cmd) -> Option<i32> {
    write(command_name, cmd);
    println!(r#"Running command "{}"..."#, command_name);
    run_command(command_name, cmd)
}

fn write(command_name: &str, cmd: &Cmd) {
    let path = Path::new(PATH_STR);
    if path.exists() {
        exit!(
            "Error writing temporary file:\n  {} already exists, donkey-must be running already",
            PATH_STR
        );
    }

    let content = format!(
        r#"#!/usr/bin/env {}
# =======================================================================================
# This is a temporary file generated by donkey-make to execute command: "{}"
# This file should only exist very temporarily while it's be executed
# DO NOT EDIT THIS FILE!
# =======================================================================================
{}
"#,
        cmd.executable,
        command_name,
        cmd.run.join("\n")
    );

    match create_file(path, &content) {
        Ok(t) => t,
        Err(e) => {
            exit!("Error writing temporary file {}:\n  {}", PATH_STR, e);
        }
    };
}

fn run_command(command_name: &str, cmd: &Cmd) -> Option<i32> {
    let command_str = format!("./{}", PATH_STR);
    let mut c = Command::new(command_str);
    c.args(&cmd.args).envs(&cmd.env);
    let status = match c.status() {
        Ok(t) => t,
        Err(e) => {
            delete();
            exit!("failed to execute command ./{}: {}", PATH_STR, e);
        }
    };
    delete();
    if status.success() {
        println!("Command \"{}\" successful", command_name);
        return None;
    } else {
        match status.code() {
            Some(c) => {
                println!("Command \"{}\" failed, exit code {}", command_name, c);
                return Some(c);
            }
            None => {
                println!(
                    "Command \"{}\" failed, no exit code (probably terminated by a signal)",
                    command_name
                );
                return Some(2);
            }
        }
    };
}

fn delete() {
    let path = Path::new(PATH_STR);
    match fs::remove_file(path) {
        Ok(t) => t,
        Err(e) => {
            exit!("Error deleting temporary file {}, {}", PATH_STR, e);
        }
    };
}

fn create_file(path: &Path, content: &str) -> std::io::Result<()> {
    let mut f = fs::File::create(path)?;
    f.write_all(content.as_bytes())?;

    let mut perms = f.metadata()?.permissions();
    let mode = perms.mode();
    perms.set_mode(mode | 0o100);
    f.set_permissions(perms)?;
    return Ok(());
}
